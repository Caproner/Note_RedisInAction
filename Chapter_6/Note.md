# 第6章 使用Redis构建应用程序组件

本章举了几个例子说明Redis在构建应用程序的作用，包括：

+ 自动补全
+ 分布式锁
+ 计数信号量
+ 任务队列
+ 消息拉取

## 自动补全

Redis可用于字符串的自动补全。针对不同的自动补全场景采用不同的Redis数据组织方案。

### 自动补全最近联系人

这类自动补全仅要求匹配**热数据**（例如说最近xx条数据），这意味着其数据量很小。

所以只需要维护一个保存最近数据（也就是最近联系人）的队列即可。这里可以直接使用列表结构实现。

具体操作为：

+ 添加最近联系人：将该联系人用`LREM`从队列里移除（如果有的话），再用`LPUSH`添加至队首
+ 取最近联系人列表：直接`LRANGE`取整个列表即可

对于自动补全操作，则交由服务端程序通过Redis取得的列表来逐一匹配即可。

每个操作的时间复杂度均为$O(n)$，其中n为队列长度。

### 通讯录自动补全

这种场景要求匹配全量数据，这意味着数据量会很大，$O(n)$的方法不适用于这种场景。

于是就需要利用字符串的有序性，使用Redis有序集合来存储数据。

但是这里不依赖分值进行排序，而是**将其全置为0，利用键值的字符串顺序**进行排序。

#### 自动补全范围查询算法

> 这里假设所有存储的字符串都是小写字母

自动补全的本质是从数据集中寻找特定前缀的字符串集。而这些字符串在顺序中是集中在一起的。

例如说寻找前缀为`abc`的字符串，那么其肯定位于`abbzz....`和`abd`之间。

因为在ASCII码里，字母`z`的下一个字符就是`{`，所以可以人为制造两个字符串`abb{`和`abc{`，这样前缀为`abc`的字符串当且仅当位于区间`("abb{", "abbc{")`中。

于是只需要：

+ 在有序集中用`ZADD`插入`abb{`和`abc{`
+ 用`ZRANK`获取`abb{`和`abc{`的位置
+ 用`ZRANGE`获取位于上面两个字符串间的数据
  + 为了避免滋扰用户，一般只获取前几个数据，例如说前十
+ 用`ZREM`删除`abb{`和`abc{`

注意整个过程需要用事务包裹，或者需要排除多个进程同时进行自动补全导致的数据错误（最有可能的就是将其他进程塞入的特殊字符串一并读取进去）

这么做的时间复杂度为$O(\log n)$，其中n为数据量

## 分布式锁

使用`WATCH`可以实现乐观锁，但在高并发的场景下使用这种方式上锁会出现活锁导致进程被饿死。故需要考虑实现一个悲观锁。Redis分布式锁正是悲观锁的一种实现。

其实现基于Redis中的`SETNX`命令。使用该命令设置某个键（代表锁的键）为一个唯一ID成功时表示获取到这把锁，失败的话表示这把锁已经被其他进程获取。

释放锁的过程也很简单：先`WATCH`这个键，然后对比键值是否为之前定的唯一ID，是的话删除改键即可。

> 看起来像是不存在键值与唯一ID不匹配的情况，但其实如果使用了下面的设置自动超时之后，当进程A获取到锁并超时，然后进程B因为进程A超时而获得锁，之后进程A再去释放锁的时候就会遇到这种情况。
>
> 此时进程A已经不是获得锁的人了，故其无法释放锁。所以当键值不匹配时无法释放锁。

### 设置自动超时

为了防止因为获取到锁的进程崩溃导致锁一直没被释放，故需要给锁设置超时时间。

现阶段的Redis支持使用`SET`命令并带`NX`和`EX`选项来原子的设置锁并设置超时时间。

> 如果不支持的话则需要用`EXPIRE`来另外设置超时时间，这个时候就需要注意进程在`SETNX`和`EXPIRE`之间崩溃时的操作了（为了防止这种情况需要时刻保证锁是有超时时间的，例如开个守护进程搞定此事）

### 什么时候需要上锁

一般情况下，当一个事务需要使用Redis本身的值去更新Redis的数据的时候，就表明已经产生竞争条件，故就需要上锁了。

这里也可以扩展到其他类似事件中，例如在修改文件信息时出现竞争条件了也可以用Redis锁。

## 计数信号量

计数信号量用于实现类似PV原语操作的方式。也就是实现例如【某个资源最多只允许n个用户同时访问】的请求。

### 简易计数信号量

直接使用一个有序集合即可。集合的键记录访问资源的进程的唯一标识，值则为进程访问的时间戳。

当一个进程要访问资源时需要将自己的唯一标识带上时间戳插入进有序集合中，并询问排名，若排名大于等于n则获取失败（也就是当前资源访问量已达到最大值n），此时需要删除自己插入的键。

释放也很简单，直接删除即可。

自动超时也很简单，定时（或惰性地）对集合进行区间修剪即可。

### 公平计数信号量

上面的计数信号量依赖于一个条件就是，所有进程的时间是一致的。但事实上每个进程间的时间都有可能差那么1一点，这会导致时钟慢的进程抢到信号量的情况。

为了针对这点，需要使用另外一个有序集合来进行信号量获取判定。新的有序集合的键仍旧是进程唯一标识，值则是一个计数（这个计数来自一个计数器变量，我们可以通过`INCR`命令另其原子自增并获取计数）。

于是插入和删除的时候除了操作记时间戳的集合，还需要操作记计数的集合。并且询问排名的操作改为询问记计数的集合的排名。

自动超时仍旧使用记时间戳的集合，但要注意删除的时候要连同记计数的集合一起删（可以利用`ZINTERSTORE`实现）

### 刷新信号量

有时候需求会要求我们定时刷新信号量的时间防止其超时之后还要重新获取。这个时候只需要修改记时间戳的集合即可。

### 消除竞争条件

> 竞争条件：进程A和进程B同时抢最后一个信号量

显然这就是需要上锁的场景。那么只需要在执行获取信号量的操作之前上锁即可（之后需要释放锁）。

## 任务队列

应用程序会有需要执行一些长时间任务的需求。这显然不适合在网络请求中执行。

于是就需要使用任务队列来管理和执行任务。

任务队列分为两种：FIFO和延时队列

### FIFO队列

也就是先进先出队列。需要执行的任务会被置于队尾，然后会有一个守护进程不断从队首中获取任务并执行。

每个任务的信息可以用一个JSON结构包装起来并作为字符串`RPUSH`仅Redis的列表里。守护进程可以使用带阻塞的`BLPOP`获取任务（需要设置最大阻塞时限，例如30秒。超过这个时限则重试）。

### 区分任务优先级

有时候每个任务的优先级并不一致。高优先级的任务会被要求更早的执行。

简单粗暴的解决方法就是设置多个任务队列，在高优先级队列阻塞的时候再去取低优先级的队列。

`BLPOP`指令可以同时按顺序指定多个列表来达到上述效果。

### 延时队列

并不是所有的任务都会被要求立即执行。有些任务会要求延时执行。

这个时候就需要用一个有序集合管理这些延时中的任务，将任务的JSON结构作为键，将执行的时间戳作为分值存储即可。

另起一个守护进程定时（每隔一小段时间，或者自适应地）询问有序集合中的最小元素是否可执行（分值是否小于等于当前时间戳），是的话**将任务置入FIFO队列中**。

> 需要注意的有：
>
> 1. 执行任务的队列需要统一使用FIFO，延时队列仅仅是为了控制延时
> 2. 由于有序集合并没像列表的`LPOP`这样的取出同时删除的原子操作，故从有序集合中取出元素时需要注意上锁

## 消息拉取

事实上便是之前介绍过的消息订阅/分发的模式。虽然Redis已经有了`PUBLISH`和`SUBSCRIBE`了，但其并不是一个完全可靠的消息订阅分发机制（例如当客户端下线时就会漏掉离线过程中的消息）。

故我们需要利用Redis的其他数据结构来自己实现一个可靠的消息拉取。

### 单接收者消息拉取

当消息的接收者只有一人的时候，也就是接近于社交网络中的单聊模式。这个时候只需要仿照任务队列建一个FIFO的队列即可。

发送者往队列中`RPUSH`消息，接收者用`BLPOP`消费队列里的消息。

### 多接收者消息拉取

多接收者的场景类似于社交网络中的群聊模式。这个时候直接使用消息队列显然是不行的（强制使用会导致消息冗余）。

于是我们可以修改一下接收消息的形式，从直接消费队列里的消息改为**用一个下标记录接收者当前所处的位置**（小于等于下标的表示未消费，大于的则是已消费）。

那么我们就只需要针对每个群聊创建一个消息队列，然后再使用两类有序集合管理下标：

+ 针对群聊的有序集合：键为用户ID，分值为用户在当前群聊消息队列的下标
+ 针对用户的有序集合：键为群聊ID，分值为用户在当前群聊消息队列的下标

需要注意的一点是要**适时清掉群聊队列中所有人读过的消息**，以防产生冗余。这里只需要利用有序集合的有序性直接获取群聊有序集合的最小值就可以做到了。

