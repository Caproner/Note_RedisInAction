# 第11章 Redis的Lua脚本编程

本章主要讨论使用Lua脚本运行Redis命令

## 使用Lua脚本

Redis提供了一系列命令用于运行包含Redis命令的Lua脚本：

+ `SCRIPT LOAD ${LuaScript}`：载入Lua脚本，返回其SHA1校验和
+ `EVALSHA ${LuaSha}`：使用SHA1校验和运行Lua脚本
+ `EVAL ${LuaScript}`：直接运行Lua脚本
+ `SCRIPT FLUSH`：清除所有缓存的Lua脚本

使用Lua脚本需要注意的地方有：

+ 运行Lua脚本这件事情是原子的，这也是其最大作用
+ 将多个Redis命令集成到Lua脚本里还可以减少通信往返次数
+ 运行的Lua脚本在其返回结果之前不会自行中断
  + 这就意味着需要外力强制中断Lua脚本的运行
  + 当该脚本操作只有读操作时，当该脚本运行时间超过`lua-time-limit`（配置项里有这个）时，运行`SCRIPT KILL`命令可以1杀死这些超时的脚本
  + 当该脚本操作包含写操作时，光是杀死超时脚本会导致数据不一致（存在写一半的情况），这个时候就只能使用`SHUTDOWN NOSAVE`命令在不持久化的情况下杀死Redis服务器，使其重启之后读取之前持久化的数据来覆盖掉之前的写操作
  + 但根源上还是需要避免Lua脚本无限运行的情况发生

## 用Lua重写锁

由于Lua脚本本身自带的原子性和通信次数减少，使得我们可以轻易地实现分布式锁：

+ 获得锁：直接判断代表锁的键是否有值，没有的话使用`SETEX`命令设置其值为自身特征值并加上过期时间

+ 释放锁：判断锁的值是否是自身特征值，是的话删除键

这些操作直接写进Lua脚本里即可。

## 用Lua重写信号量

同样，我们也可以利用其原子性重写信号量

此时我们不需要维护计数器和计数有序集合，只需要维护时间戳有序集合就行

操作如下：

+ 获得信号量：先用`ZREMRANGEBYSCORE`清空超时的信号量，再判断有序集合大小是否等于最大信号数量，否的话将当前时间戳和自身特征值放入即可
+ 释放信号量：不需要Lua脚本，直接从有序集合里删除就行
+ 刷新信号量：检查信号量是否存在，存在的话重新赋值就行

这样即使不需要锁也可以实现公平信号量

## 分片列表

分片列表的思想是：

+ 每个片都有一个编号，其有大小限制（例如说最多64个元素）
+ 再加两个键存储【最左端编号】和【最右端编号+1】，当这两个值相等时列表为空

然后利用Lua脚本的原子性就可以将复杂的操作封装起来实现使得其保证一致性