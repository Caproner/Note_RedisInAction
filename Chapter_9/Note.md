# 第9章 降低内存占用

本章主要讨论Redis常用的降低内存的方法，包括：

+ 短结构
+ 分片结构
+ 打包存储二进制位和字节

## 短结构

> 对于字符串而言没有短结构，这里仅讨论列表、哈希表、集合、有序集合等可以存储多个元素的数据结构

Redis的数据结构的底层实现使得每个元素都需要存储过多的额外信息（包括指针、长度等），这些额外信息的目的是减少Redis结构的读写时间复杂度。

但当该数据结构存的数据较少时，额外的信息减少不了多少读写时间，此时这些额外信息就成了累赘。

故Redis自带一种称为**短结构**的底层实现，当数据量过小时会采用短结构进行存储。

### 压缩列表

对于列表、哈希表、有序集合而言，当数据元素个数过少时，其底层使用压缩列表（ziplist）。

压缩列表本质为一个由节点组成的序列，每个节点包括前一个节点的字符串长度、当前节点的字符串长度、当前节点的值组成（按顺序从左到右存储）。

其存储性质决定了其CRUD的复杂度会比较高，但其所使用的额外内存极少（当前节点的字符串长度用于正向遍历，前一个节点的字符串长度用于反向遍历），故适用于数据元素较少的场景。

其可以由如下配置项配置Redis数据结构何时使用压缩列表：

```
list-max-ziplist-entries 512
list-max-ziplist-value 64

zset-max-ziplist-entries 512
zset-max-ziplist-value 64

hash-max-ziplist-entries 512
hash-max-ziplist-value 64
```

其中`entries`项决定了压缩列表的最大元素个数，`value`项决定了压缩列表中每个元素最大所占的字节数。

当其任意一个条件不满足时，Redis将不再使用压缩列表存储，而改为其原本使用的底层数据结构。

注意，从压缩列表改为原本的数据结构这个操作具有**不可逆性**，换言之，其无法重新变为压缩列表。

> 现如今列表已经不使用`ziplist`了，而是使用`quicklist`

### 整数集合编码

对于集合而言，当且仅当其数据元素个数少且均为平台的带符号整数范围内的整数时，其以有序整数数组的形式进行存储，也就是整数集合编码。

其可以由配置项`set-max-intset-entries`配置其最大元素个数。

显然的，其性能也不咋地。

## 分片结构

分片结构的本质思想是，将一个大的数据结构分为多个小的数据结构（例如把哈希表`test:hash`分为`test:hash:01`、`test:hash:02`、。。。），利用每个分片的短结构达到在CRUD耗时基本差不多的情况下减少内存开销。

不同的数据结构的分片策略不尽相同，其中分片列表的操作需要借助Lua脚本实现故放在第11章讲，分片有序集合难以实现集合运算和排序，以及由于其结构的特殊性使其使用起来反而会增大时耗（区间操作往往需要动到多个分片），故此处只讨论**分片散列和分片集合**。

分片散列和分片集合的本质是一样的，将表里的键进行哈希计算得到一个值，以这个值为基准分为多个哈希表（集合的底层也是哈希表，故这里一并讨论）。其实就相当于再哈希一次。

## 打包存储二进制位和字节

这种操作的思想是将连续的信息转化为二进制位存入字符串中，并使用`GETRANGE`、`SETRANGE`、`GETBIT`、`SETBIT`等针对位的操作来操作这些信息。

例如说我们需要存用户的位置信息。假设位置信息可以转化为4个位的信息，我们就可以用一段连续的数位来存储每个用户的位置信息。这样既可以一次性取出所有用户的信息，又可以实现单点修改和批量修改。

当数据量过大时，为了避免偏移量过大带来的时耗提升，可以结合分片技术一起使用。